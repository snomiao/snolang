打印 = (...参数) => (console.log(...参数), 参数[0])
表格打印 = (...参数) => (console.table(...参数), 参数[0])
监视器 = (名义) => (...参数) => (console.log(时刻串取(), 名义, ...参数), 参数[0])

stage1 = `
_1 + _2 => (_1 + _2)
_1 - _2 => (_1 - _2)


_1 * _2 => (_1 * _2)
_1 - _2 => (_1 - _2)
`

stage2 = `
斐 0 => (1)
斐 _ => $1 * (斐 $1 -1)
`
// 内置规则（或……函数？不管了都一样
var 分级规则列列 = [
    [
        ['! _数'.split(' '), (a, b) => [!b]],
        ['- _数'.split(' '), (a, b) => [- b]],
        ['二对数 _数'.split(' '), (a, b) => [Math.log2(parseFloat(b))]],
        ['对数 _数'.split(' '), (a, b) => [Math.log(parseFloat(b))]],
    ], [
        ['_数 ^ _数'.split(' '), (a, b, c) => [parseFloat(a) ** parseFloat(c)]],
    ], [
        ['_数 * _数'.split(' '), (a, b, c) => [parseFloat(a) * parseFloat(c)]],
        ['_数 / _数'.split(' '), (a, b, c) => [parseFloat(a) / parseFloat(c)]],
    ], [
        ['_数 + _数'.split(' '), (a, b, c) => [parseFloat(a) + parseFloat(c)]],
        ['_数 - _数'.split(' '), (a, b, c) => [parseFloat(a) + parseFloat(c)]],
    ], [
        ['列 __'.split(' '), (a, ...b) => [b]],
        ['求和 __'.split(' '), (a, b, c) => [a + '.' + c]],
        ['_ 的 _'.split(' '), (a, b, c) => [a + '.' + c]],
        ['_ 应用 _'.split(' '), (a, b, c) => [c, a]],
        ['_ 求于 _'.split(' '), (a, b, c) => [a, c]],
        ['如果 _ 那么 _ 否则 _'.split(' '), (_1, a, _2, b, _3, c) => [a, "?", b, ':', c]],
        ['_ ? _ : _'.split(' '), (a, _2, b, _3, c) => [a ? b : c]],
    ]
]

var 测试用例 = [
    [`基本算术`, `2 * ( 1 + 1 )`, `4`],
    [`基本算术`, `((1 * 5) * (2 ^ 10))`, `5120`],
    [`基本算术`, `1 + (- 2) * -3 + 4`, `11`],
    [`基本算术`, `- 1 + 1`, `0`],
    [`基本算术`, `1 + 2 * 3`, `7`],
    [`基本算术`, `1 + 2 * 3 ^ 2`, `19`],
    [`基本算术`, `2 ^ 4 ^ 2`, `256`],
    [`基本算术`, `2 ^ (4 ^ 2)`, `65536`],
    [`符号保留`, `(1 + 1 ) 切 2`, `( 2 切 2 )`],
    [`符号保留`, `(1 + 1 ) 切 (2 * 2 )`, `( 2 切 4 )`],
    [`函数范式`, `1 + (二对数 65536)`, `17`],
    [`函数范式`, `二对数 65536`, `16`],
    [`函数范式`, `二对数 求于 65536`, `16`],
    [`函数范式`, `65536 应用 二对数`, `16`],
    [`函数范式`, `16 应用 二对数`, `4`],
    [`函数范式`, `65536 应用 二对数 应用 二对数`, `4`],
    [`多重参数`, `求和 1 2 3 4`, `11`],
    [`流程控制`, `如果 0 那么 我也爱你 否则 我恨你`, `我恨你`],
    [`流程控制`, `如果 1 那么 我也爱你 否则 我恨你`, `我也爱你`],
    // [`缩进结构`, `如果 你爱我\n    那么 我也爱你\n    否则 我恨你`, `我也爱你`],
]
var 测试结果 = 测试用例.map(([类型, 输入, 预期]) => {
    var 输出 = 编译(输入)
    监视器('输出')(输入, '=>', 输出)
    return 输出 !== 预期
        ? { 类型, 输入, 输出, 测试: 预期 }
        : { 类型, 输入, 输出, 测试: '成功！' }
})
表格打印(测试结果)

function 编译(输入) {
    var 初始状态 = {
        缓存: '',
        内栈: [],
        外栈: [],
        输出: '',
    }
    var 终止状态 = ("(" + 输入 + ")").split('')
        .reduce((状态, 字符, 序号, 长度) => {
            var { 缓存, 内栈, 外栈 } = 状态
            if (字符 === '(') {
                false && 监视器('栈前')({ 缓存, 内栈, 外栈 })
                外栈.push(内栈.splice(0))
                false && 监视器('栈后')({ 缓存, 内栈, 外栈 })
            } else if (字符 === ')') {
                缓存压栈()
                while (分级模式替换(内栈));
                内栈 = 内栈.length > 1
                    ? [...外栈.pop(), '(', ...内栈, ')']
                    : [...外栈.pop(), ...内栈]
            } else {
                缓存 += 字符
                if (' \t\r\n'.indexOf(字符) + 1
                    || 序号 === 长度.length - 1) {
                    缓存压栈()
                }
            }
            return 监视器('状态')({ 字符, 缓存, 内栈, 外栈 })
            function 缓存压栈() {
                缓存 = 缓存.trim()
                if (!缓存) return;
                if (!isNaN(parseFloat(缓存))) {
                    内栈.push(Number(缓存))
                } else {
                    内栈.push(String(缓存))
                }
                缓存 = ''
            }
        }, 初始状态)
    var 输出 = 终止状态.内栈
    return 输出.join(' ')
}

function 分级模式替换(内栈) {
    return 分级规则列列.some(规则列 => 内栈.some((_, i) => 规则列.some(([模式, 替换函数]) => {
        const 子栈 = 内栈.slice(i, i + 模式.length)
        // 监视器('尝试替换')({ 模式, 内栈, 子内栈: 内栈.slice(i, i + 模式.length) })
        if (模式.length <= 子栈.length &&
            模式.every((_格子, 序号) => {
                return (模式[序号] === '_') ||
                    ((模式[序号].startsWith('_')) && 模式[序号].slice(1)) ||
                    (模式[序号] === 子栈[序号])
            })) {
            内栈.splice(
                i,
                模式.length,
                ...替换函数(
                    ...子栈
                ))
            return true
        }
        return false
    })))
    // return 内栈
}

function 时刻串取() {
    // return new Date(
    //     +new Date() - new Date().getTimezoneOffset() * 60e3)
    //     .toISOString().replace(/[-:]/g, '').slice(0, 8 + 6+1)
    return new Date().toLocaleTimeString()
}

function 压栈(字符, i, 长度) {

}
